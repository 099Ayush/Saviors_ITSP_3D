<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saviors Prediction Model</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');
        * {
            font-family: Orbitron, sans-serif;
        }
        body {
            margin: 0;
        }
        #welcome {
            position: fixed;
            z-index: 1000;
            width: 100%;
            height: 100%;
            color: white;
            font-family: Orbitron, sans-serif;
            font-size: xx-large;
            transition: 0.5s opacity;
        }
        canvas {
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        span {
            color: white;
        }
        td {
            text-align: center;
            background: black;
        }
        button {
            font-family: Orbitron, sans-serif;
            background: white;
            border: none;
            transition: all 0.2s;
            cursor: pointer;
        }
        button:hover {
            background: black;
            color: white;
        }
    </style>
</head>
<body>
<div id="welcome">
    <table style="width: 100%; height: 100%">
        <tr style="height: 100%">
            <td>LOADING...</td>
        </tr>
    </table>
</div>
<div style="position: fixed">
    <table>
        <tr>
            <td><button id="play">Play</button></td>
            <td><button id="res">Resolution</button></td>
            <td><button id="cam">Camera</button></td>
            <td><button id="bld">Buildings</button></td>
            <td style="color: white; width: 100%">1<input type="range" id="cam_attach" min="1" max="100" value="1" style="width: 100%">100</td>
        </tr>
        <tr>
            <td></td>
            <td><span id="res_value">1</span></td>
        </tr>
    </table>
</div>
<script src="build/jquery.min.js"></script>
<script type="module">

    // Imports
    import * as THREE from './build/three.module.js';
    import {GLTFLoader} from "./build/GLTFLoader.js";

    // Scene and Renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x64ceeb);
    const renderer = new THREE.WebGLRenderer({
        antialias: true
    });
    renderer.setSize(innerWidth, innerHeight, false);
    document.body.appendChild(renderer.domElement);

    // Ambient Light
    const hlight = new THREE.AmbientLight(0xffffff, 10);
    scene.add(hlight);

    // Directional Light
    const dlight = new THREE.DirectionalLight(0xffffff, 10);
    dlight.position.set(0, 1, 0);
    scene.add(dlight);

    // Create the ground.
    const base_material = new THREE.MeshBasicMaterial({
        color: 0x88ff88
    });
    const base_geometry = new THREE.BoxGeometry(1000, 1, 1600);
    const base = new THREE.Mesh(base_geometry, base_material);
    base.position.y = - 0.55;
    scene.add(base);

    // Create the road
    const road_material = new THREE.MeshBasicMaterial({
        color: 0x444444
    });
    const road_mark_material = new THREE.MeshBasicMaterial({
        color: 0xffffff
    })
    const road_geometry = new THREE.BoxGeometry(7, 0.1, 1600);
    const road_mark_geometry = new THREE.BoxGeometry(0.15, 0.3, 1.5);
    const road_base = new THREE.Mesh(road_geometry, road_material);
    scene.add(road_base);
    road_base.position.y = -0.005;
    for (let i = -1000; i < 10000; i++) {
        let road_mark = new THREE.Mesh(road_mark_geometry, road_mark_material);
        scene.add(road_mark);
        road_mark.position.set(0, 0, -4.5 * i);
    }

    // Load building model.
    const loader = new GLTFLoader();
    loader.load(
        'build/models/model3/scene.gltf',
        function (build) {
            // Place the buildings in a pattern.
            let bld_group = new THREE.Group();
            for (let i = 0; i < 1000; i++) {
                let home = build.scene.clone();
                bld_group.add(home);
                home.scale.set(0.005, 0.005, 0.005);
                home.position.set(-16, -5, -100 * i);
                let home2 = build.scene.clone();
                bld_group.add(home2);
                home2.scale.set(0.005, 0.005, 0.005);
                home2.position.set(16, -5, -100 * i - 25);
            }

            // Load the 3d model of the car.
            loader.load(
                'build/models/model1/scene.gltf',
                function (model) {

                    $('#welcome').css('opacity', '0');
                    setTimeout(function() {
                        $('#welcome').css('display', 'none');
                    }, 500);
                    // Dummy box to determine the dimensions of the car model.
                    const dummy_box = new THREE.Box3().setFromObject(model.scene);
                    const size_vector = new THREE.Vector3();
                    dummy_box.getSize(size_vector);

                    // Factors to accordingly resize the model.
                    const x_factor = 1 / size_vector.x, y_factor = 1 / size_vector.y, z_factor = 1 / size_vector.z;

                    /** Returns a car object */
                    function Car(length, width, height, init_speed, lane, init_z) {
                        let obj = {
                            length:length,
                            width: width,
                            height: height,
                            speed: init_speed * 5 / 18,
                            lane: lane,
                            accn: 0,
                            overtaking_phase: 0,
                            object: model.scene.clone()
                        };
                        obj.object.scale.set(x_factor * width, y_factor * height, z_factor * length);
                        let init_x;
                        if (lane === 1) {obj.object.rotation.y = Math.PI; init_x = -1.75;} else init_x = 1.75;
                        obj.object.position.set(init_x, 0, init_z);
                        return obj;
                    }

                    // The array of all cars in the city.
                    const cars = [];
                    for (let i = 0; i < 100; i += 2) {
                        cars.push(new Car(5, 2, 1.5, 70 + Math.random() * 70, 1, -100 * (i + Math.random())));
                        scene.add(cars[i].object);
                        cars.push(new Car(5, 2, 1.5, -70 - Math.random() * 70, -1, -100 * (i + 1 + Math.random())));
                        scene.add(cars[i + 1].object);
                    }

                    let order = [...Array(cars.length).keys()];
                    for (let i = 0; i < cars.length; i++) {
                        update_rel(i);
                    }

                    let t1, frame_rate = 60, focus = cars[0], safe_distance = 10;
                    // Perspective Camera
                    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.01, 800);
                    camera.position.set(focus.object.position.x + 0.3 * focus.lane, 1.3, focus.object.position.z + 0.2 * focus.lane);
                    camera.lookAt(focus.object.position.x + 0.3 * focus.lane, 0, focus.object.position.z-1000 * focus.lane);
                    renderer.render(scene, camera);

                    function play() {
                        let t0 = $.now();
                        setInterval(function () {
                            t1 = $.now();

                            cars.forEach(function(car, index) {
                                car.object.position.z -= car.speed * (t1 - t0) / 1000;
                                if (car.car1 !== null) {
                                    if (car.lane * car.object.position.z <= car.lane * (car.car1.object.position.z + safe_distance * car.lane) && car.car1.speed * car.lane < car.speed * car.lane) {
                                        car.overtaking_phase = 1;
                                        if (car.lane * car.object.position.x >= 1.75) {
                                            car.overtaking_phase = 2;
                                        }
                                    }
                                    if (car.lane * car.object.position.z + car.length / 2 <= car.lane * car.car1.object.position.z - car.car1.length / 2) {
                                        car.overtaking_phase = 2.5;
                                    }
                                    if (car.overtaking_phase === 1) {
                                        car.object.position.x += 3.5 / 1.5 * (t1 - t0) / 1000 * car.lane;
                                    }
                                    if (car.overtaking_phase === 2.5) {
                                        let a = order.indexOf(index);
                                        order[a] = order[a + car.lane];
                                        order[a + car.lane] = index;
                                        update_rel(index);
                                        update_rel(order[a]);
                                        car.overtaking_phase = 3;
                                    }
                                }
                                if (car.overtaking_phase === 3) {
                                    car.object.position.x -= 3.5 / 1.5 * (t1 - t0) / 1000 * car.lane;
                                    if (car.lane * car.object.position.x <= -1.75) {
                                        car.overtaking_phase = 0;
                                    }
                                }
                            });
                            change_cam();
                            transit_road();
                            t0 = $.now();
                            renderer.render(scene, camera);
                        }, 1000 / frame_rate);
                    }

                    // Display parameters
                    let resolution = 1, bcamera = 1, buildings = false;
                    $('button#res').click(function () {
                        resolution = resolution % 3 + 1;
                        renderer.setSize(innerWidth / resolution, innerHeight / resolution, false);
                        $('span#res_value').html('1 / ' + resolution);
                        renderer.render(scene, camera);
                    });

                    $('button#cam').click(function () {
                        bcamera = bcamera % 3 + 1;
                        change_cam();
                        renderer.render(scene, camera);
                    });

                    $('button#bld').click(function () {
                        buildings = !buildings;
                        if (buildings) {
                            scene.add(bld_group);
                        } else {
                            scene.remove(bld_group);
                        }
                        renderer.render(scene, camera);
                    });

                    $('input#cam_attach').on('input', function () {
                        focus = cars[$('input#cam_attach').val() - 1];
                        change_cam();
                        transit_road();
                        renderer.render(scene, camera);
                    });

                    $('button#play').click(function () {
                        play();
                    });

                    function change_cam () {
                        if (bcamera === 1) {
                            camera.position.set(focus.object.position.x + 0.3 * focus.lane, 1.3, focus.object.position.z + 0.2 * focus.lane);
                            camera.lookAt(focus.object.position.x + 0.3 * focus.lane, 0, focus.object.position.z-1000 * focus.lane);
                        } else if (bcamera === 2) {
                            camera.position.set(focus.object.position.x, 3, focus.object.position.z + 5 * focus.lane);
                            camera.lookAt(focus.object.position.x, 0, focus.object.position.z-1000 * focus.lane);
                        } else {
                            camera.position.set(0, 50, focus.object.position.z + 50 * focus.lane);
                            camera.lookAt(0, 0, focus.object.position.z - 30 * focus.lane);
                        }
                    }

                    function transit_road() {
                        base.position.z = focus.object.position.z;
                        road_base.position.z = focus.object.position.z;
                    }


                    function update_rel(index) {
                        let found1 = false, found2 = false;
                        let lane = cars[index].lane;
                        let ii = order.indexOf(index);
                        for (let i = ii + lane; lane * i < cars.length * (1 + lane) / 2; i += lane) {
                            if (!found1 && cars[order[i]].lane === lane) {
                                cars[index].car1 = cars[order[i]];
                                found1 = true;
                            } else if (!found2 && cars[order[i]].lane === -lane) {
                                cars[index].car2 = cars[order[i]];
                                found2 = true;
                            } else if (found1 && found2) {
                                break;
                            }
                        }
                        if (!found1) cars[index].car1 = null;
                        if (!found2) cars[index].car2 = null;
                    }
                }
            );
        }
    );

</script>
</body>
</html>
